class B{constructor(){this.children={},this.isEndOfWord=!1,this.handler=[],this.isDynamic=!1,this.pattern="",this.path="",this.method=[],this.subMiddlewares=new Map}}class A{constructor(){this.root=new B}insert(J,L){let G=this.root;const X=J.split("/").filter(Boolean);if(J==="/"){G.isEndOfWord=!0,G.handler.push(L.handler),G.path=J,G.method.push(L.method);return}for(let U of X){let Y=!1,Z=U;if(U.startsWith(":"))Y=!0,Z=":";if(!G.children[Z])G.children[Z]=new B;G=G.children[Z],G.isDynamic=Y,G.pattern=U}G.isEndOfWord=!0,G.method.push(L.method),G.handler.push(L.handler),G.path=J}insertMidl(J){if(!this.root.subMiddlewares.has(J))this.root.subMiddlewares.set(J)}search(J,L){let G=this.root;const X=J.split("/").filter(Boolean);for(let Y of X){let Z=Y;if(!G.children[Z])if(G.children[":"])G=G.children[":"];else return null;else G=G.children[Z]}let U=G.method.indexOf(L);if(U!==-1)return{path:G.path,handler:G.handler[U],isDynamic:G.isDynamic,pattern:G.pattern,method:G.method[U]};return{path:G.path,handler:G.handler,isDynamic:G.isDynamic,pattern:G.pattern,method:G.method[U]}}getAllRoutes(){const J=[],L=(G,X)=>{if(G.isEndOfWord)J.push({path:X,handler:G.handler,isImportant:G.isImportant,isDynamic:G.isDynamic,pattern:G.pattern});for(let U in G.children){const Y=G.children[U],Z=X+(U===":"?"/:"+Y.pattern:"/"+U);L(Y,Z)}};return L(this.root,""),J}}async function M(J){const L={};if(!J)return L;return J.split(";").forEach((X)=>{const[U,Y]=X.trim().split("=");L[U]=Y.split(" ")[0]}),L}function b(J,L){const G={},X=J.split("/"),[U]=L.split("?"),Y=U.split("/");if(X.length!==Y.length)return null;return X.forEach((Z,z)=>{if(Z.startsWith(":")){const V=Z.slice(1);G[V]=Y[z]}}),G}async function I(J){const L=J.headers.get("Content-Type")||"";if(!L)return{};try{if(L.startsWith("application/json"))return await J.json();if(L.startsWith("application/x-www-form-urlencoded")){const G=await J.text();return Object.fromEntries(new URLSearchParams(G))}if(L.startsWith("multipart/form-data")){const G=await J.formData();return T(G)}return new Response({error:"Unknown request body type"})}catch(G){return new Response({error:"Invalid request body format"})}}function T(J){const L={};for(let[G,X]of J.entries())L[G]=X;return L}function Q(J,L){let G={},X={},U=!1,Y=null,Z=null,z=null,V=null,W=200;return{req:J,url:L,next:()=>{},status(_){return W=_,this},async body(){if(!V)V=await I(J);return V},setHeader(_,$){return G[_]=$,this},set(_,$){return X[_]=$,this},get(_){return X[_]},setAuth(_){return U=_,this},getAuth(){return U},text(_,$){if($)W=$;return new Response(_,{status:W,headers:G})},json(_,$){if($)W=$;return new Response(JSON.stringify(_),{status:W,headers:{"Content-Type":"application/json",...G}})},html(_,$){if($)W=$;return new Response(Bun.file(_),{status:W,headers:{...G}})},file(_,$){if($)W=$;return new Response(Bun.file(_),{status:W,headers:{...G}})},redirect(_,$){if($)W=$;return new Response(null,{status:W,headers:{Location:_,...G}})},getParams(_){if(!z)z=b(J.routePattern,L.pathname);return _?z[_]:z},getQuery(_){if(!Y)Y=Object.fromEntries(L.searchParams);return _?Y[_]:Y},async cookie(_,$,F={}){let E=`${encodeURIComponent(_)}=${encodeURIComponent($)}`;if(F.maxAge)E+=`; Max-Age=${F.maxAge}`;if(F.expires)E+=`; Expires=${F.expires.toUTCString()}`;if(F.path)E+=`; Path=${F.path}`;if(F.domain)E+=`; Domain=${F.domain}`;if(F.secure)E+="; Secure";if(F.httpOnly)E+="; HttpOnly";if(F.sameSite)E+=`; SameSite=${F.sameSite}`;if(G["Set-Cookie"]){const D=Array.isArray(G["Set-Cookie"])?G["Set-Cookie"]:[G["Set-Cookie"]];D.push(E),G["Set-Cookie"]=D}else G["Set-Cookie"]=E;return this},async getCookie(_){if(!Z)Z=await M(J.headers.get("cookie"));return _?Z[_]:Z}}}async function v(J,L){for(let G of J){const X=await G(L);if(X)return X}}function C(J){return new Response(`Route not found for ${J}`,{status:404})}function O(){return new Response("Method not allowed",{status:405})}function N(){return new Response("No response from handler",{status:204})}function R(){return new Response("Internal Server Error",{status:500})}async function j(J,L,G){const X=Q(J,L);if(G.hasOnReqHook)for(let Y of G.hooks.onRequest)await Y(X);if(G.hasMiddleware){const Y=[...G.globalMiddlewares,...G.middlewares.get(L.pathname)||[]],Z=await v(Y,X);if(Z)return Z}const U=G.trie.search(L.pathname,J.method);if(!U||!U.handler)return C(L.pathname);if(U.method!==J.method)return O();if(U.isDynamic)J.routePattern=U.path;if(G.hasPreHandlerHook)for(let Y of G.hooks.preHandler){const Z=await Y(X);if(Z)return Z}try{const Y=await U.handler(X);if(G.hasPostHandlerHook)for(let Z of G.hooks.postHandler)await Z(X);if(G.hasOnSendHook)for(let Z of G.hooks.onSend){const z=await Z(Y,X);if(z)return z}return Y??N()}catch(Y){return R()}}class K{constructor(){this.routes=new Map,this.globalMiddlewares=[],this.middlewares=new Map,this.trie=new A,this.hasMiddleware=!1,this.hasOnReqHook=!1,this.hasPreHandlerHook=!1,this.hasPostHandlerHook=!1,this.hasOnSendHook=!1,this.hooks={onRequest:[],preHandler:[],postHandler:[],onSend:[],onError:[],onClose:[]}}addHooks(J,L){if(this.hooks[J])this.hooks[J].push(L);else throw new Error(`Unknown hook type: ${type}`)}compile(){if(this.globalMiddlewares.length>0)this.hasMiddleware=!0;for(let[J,L]of this.middlewares.entries())if(L.length>0){this.hasMiddleware=!0;break}if(this.hooks.onRequest.length>0)this.hasOnReqHook=!0;if(this.hooks.preHandler.length>0)this.hasPreHandlerHook=!0;if(this.hooks.postHandler.length>0)this.hasPostHandlerHook=!0;if(this.hooks.onSend.length>0)this.hasOnSendHook=!0}listen(J,{sslCert:L=null,sslKey:G=null}={},X){this.compile();const U={port:J,fetch:async(Z)=>{const z=new URL(Z.url);try{return await j(Z,z,this)}catch(V){return new Response("Internal Server Error",{status:500})}},onClose(){console.log("Server is shutting down...")}};if(L&&G)U.certFile=L,U.keyFile=G;const Y=Bun.serve(U);if(typeof X==="function")return X();if(L&&G)console.log(`HTTPS server is running on https://localhost:${J}`);else console.log(`HTTP server is running on http://localhost:${J}`);return Y}register(J,L){const G=Object.entries(L.trie.root.children);L.trie.root.subMiddlewares.forEach((X,U)=>{if(!this.middlewares.has(J+U))this.middlewares.set(J+U,[]);if(!this.middlewares.get(J+U).includes(...X))this.middlewares.get(J+U).push(...X)});for(let[X,U]of G){const Y=J+U?.path,Z=U.handler[0],z=U.method[0];this.trie.insert(Y,{handler:Z,method:z})}L.trie=new A}#G(J,L,G){const X=G.slice(0,-1);if(!this.middlewares.has(L))this.middlewares.set(L,[]);if(L==="/")X.forEach((Y)=>{if(!this.globalMiddlewares.includes(Y))this.globalMiddlewares.push(Y)});else if(!this.middlewares.get(L).includes(...X))this.middlewares.get(L).push(...X);const U=G[G.length-1];this.trie.insert(L,{handler:U,method:J})}use(J,L){if(typeof J==="function"){if(!this.globalMiddlewares.includes(J))return this.globalMiddlewares.push(J)}const G=J;if(!this.middlewares.has(G))this.middlewares.set(G,[]);if(!this.middlewares.get(G).includes(L))this.middlewares.get(G).push(L)}get(J,...L){return this.#G("GET",J,L)}post(J,...L){return this.#G("POST",J,L)}put(J,...L){return this.#G("PUT",J,L)}patch(J,...L){if(L.length>0)return this.#G("PATCH",J,L)}delete(J,...L){return this.#G("DELETE",J,L)}}var x=K;export{x as default};
