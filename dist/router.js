class Q{children;isEndOfWord;handler;isDynamic;pattern;path;method;subMiddlewares;constructor(){this.children={},this.isEndOfWord=!1,this.handler=[],this.isDynamic=!1,this.pattern="",this.path="",this.method=[],this.subMiddlewares=new Map}}class V{root;constructor(){this.root=new Q}insert(G,F){let z=this.root;const U=G.split("/").filter(Boolean);if(G==="/"){z.isEndOfWord=!0,z.handler.push(F.handler),z.path=G,z.method.push(F.method);return}for(let J of U){let L=!1,Y=J;if(J.startsWith(":"))L=!0,Y=":";if(!z.children[Y])z.children[Y]=new Q;z=z.children[Y],z.isDynamic=L,z.pattern=J}z.isEndOfWord=!0,z.method.push(F.method),z.handler.push(F.handler),z.path=G}search(G,F){let z=this.root;const U=G.split("/").filter(Boolean);for(let L of U){let Y=L;if(!z.children[Y])if(z.children[":"])z=z.children[":"];else return null;else z=z.children[Y]}let J=z.method.indexOf(F);if(J!==-1)return{path:z.path,handler:z.handler[J],isDynamic:z.isDynamic,pattern:z.pattern,method:z.method[J]};return{path:z.path,handler:z.handler,isDynamic:z.isDynamic,pattern:z.pattern,method:z.method[J]}}}async function D(G){const F={};if(!G)return F;return G.split(";").forEach((U)=>{const[J,L]=U?.trim()?.split("=");if(J&&L)F[J.trim()]=L.split(" ")[0].trim()}),F}function T(G,F){const z={},U=G.split("/"),[J]=F.split("?"),L=J.split("/");if(U.length!==L.length)return null;return U.forEach((Y,$)=>{if(Y.startsWith(":")){const E=Y.slice(1);z[E]=L[$]}}),z}async function b(G){const F=G.headers.get("Content-Type")||"";if(!F)return{};try{if(F.startsWith("application/json"))return await G.json();if(F.startsWith("application/x-www-form-urlencoded")){const z=await G.text();return Object.fromEntries(new URLSearchParams(z))}if(F.startsWith("multipart/form-data")){const z=await G.formData();return N(z)}return{error:"Unknown request body type"}}catch(z){return{error:"Invalid request body format"}}}function N(G){const F={};for(let[z,U]of G.entries())F[z]=U;return F}function B(G,F){let z=new Headers,U={},J=!1,L=null,Y=null,$=null,E,A=200;return{req:G,url:F,next:()=>{},status(X){return A=X,this},async body(){if(!E)E=await b(G);if(E.error)return new Response(JSON.stringify({error:E.error}),{status:400});return E},setHeader(X,Z){return z.set(X,Z),this},set(X,Z){return U[X]=Z,this},get(X){return U[X]||null},setAuth(X){return J=X,this},getAuth(){return J},text(X,Z){return new Response(X,{status:Z??A,headers:z})},json(X,Z){return new Response(JSON.stringify(X),{status:Z??A,headers:z})},html(X,Z){return new Response(Bun.file(X),{status:Z??A,headers:z})},file(X,Z){return new Response(Bun.file(X),{status:Z??A,headers:z})},redirect(X,Z){return z.set("Location",X),new Response(null,{status:Z??302,headers:z})},getParams(X){if(!$)$=T(G?.routePattern,F?.pathname);return X?$[X]||null:$},getQuery(X){if(!L)L=Object.fromEntries(F.searchParams);return X?L[X]||null:L},async cookie(X,Z,_={}){let W=`${encodeURIComponent(X)}=${encodeURIComponent(Z)}`;if(_.maxAge)W+=`; Max-Age=${_.maxAge}`;if(_.expires)W+=`; Expires=${_.expires.toUTCString()}`;if(_.path)W+=`; Path=${_.path}`;if(_.domain)W+=`; Domain=${_.domain}`;if(_.secure)W+="; Secure";if(_.httpOnly)W+="; HttpOnly";if(_.sameSite)W+=`; SameSite=${_.sameSite}`;return z?.append("Set-Cookie",W),this},async getCookie(X){if(!Y){const Z=G.headers.get("cookie");if(Z)Y=await D(Z)}return X?Y[X]||null:Y}}}async function I(G,F){for(let z of G){const U=await z(F);if(U)return U}}var K={};async function j(G,F,z){const U=B(G,F);if(z.hasOnReqHook&&z.hooks.onRequest)await z.hooks.onRequest(U);if(z.hasMiddleware){const L=[...z.globalMiddlewares,...z.middlewares.get(F.pathname)||[]],Y=await I(L,U);if(Y)return Y}let J;if(K[F.pathname+G.method])J=K[F.pathname+G.method];else J=z.trie.search(F.pathname,G.method),K[F.pathname+G.method]=J;if(!J||!J.handler)return new Response(`Route not found for ${F.pathname}`,{status:404});if(J.method!==G.method)return new Response("Method not allowed",{status:405});if(J.isDynamic)G.routePattern=J.path;if(z.hasPreHandlerHook&&z.hooks.preHandler){const L=await z.hooks.preHandler(U);if(L)return L}try{const L=await J.handler(U);if(z.hasPostHandlerHook&&z.hooks.postHandler)await z.hooks.postHandler(U);if(z.hasOnSendHook&&z.hooks.onSend){const Y=await z.hooks.onSend(U,L);if(Y)return Y}return L??new Response("No response from handler",{status:204})}catch(L){return new Response("Internal Server Error",{status:500})}}class M{routes;globalMiddlewares;middlewares;trie;hasOnReqHook;hasMiddleware;hasPreHandlerHook;hasPostHandlerHook;hasOnSendHook;hooks;constructor(){this.routes=new Map,this.globalMiddlewares=[],this.middlewares=new Map,this.trie=new V,this.hasMiddleware=!1,this.hasOnReqHook=!1,this.hasPreHandlerHook=!1,this.hasPostHandlerHook=!1,this.hasOnSendHook=!1,this.hooks={onRequest:null,preHandler:null,postHandler:null,onSend:null,onError:null,onClose:null}}addHooks(G,F){if(typeof G!=="string")throw new Error("hookName must be a string");if(typeof F!=="function")throw new Error("callback must be a instance of function");if(this.hooks.hasOwnProperty(G))this.hooks[G]=F;else throw new Error(`Unknown hook type: ${G}`)}compile(){if(this.globalMiddlewares.length>0)this.hasMiddleware=!0;for(let[G,F]of this.middlewares.entries())if(F.length>0){this.hasMiddleware=!0;break}if(this.hooks.onRequest)this.hasOnReqHook=!0;if(this.hooks.preHandler)this.hasPreHandlerHook=!0;if(this.hooks.postHandler)this.hasPostHandlerHook=!0;if(this.hooks.onSend)this.hasOnSendHook=!0}listen(G,F,{sslCert:z=null,sslKey:U=null}={}){if(typeof Bun==="undefined")throw new Error(".listen() is designed to run on Bun only...");if(typeof G!=="number")throw new Error("Port must be a numeric value");this.compile();const J=this,L={port:G,fetch:async($)=>{const E=new URL($.url);try{return await j($,E,this)}catch(A){return new Response("Internal Server Error",{status:500})}},onClose(){console.log("Server is shutting down...")}};if(z&&U)L.certFile=z,L.keyFile=U;const Y=Bun.serve(L);if(typeof F==="function")return F();if(z&&U)console.log(`HTTPS server is running on https://localhost:${G}`);else console.log(`HTTP server is running on http://localhost:${G}`);return Y}register(G,F){if(typeof G!=="string")throw new Error("path must be a string");if(typeof F!=="object")throw new Error("handler parameter should be a instance of router object",F);const z=Object.entries(F.trie.root.children);F.trie.root.subMiddlewares.forEach((U,J)=>{if(!this.middlewares.has(G+J))this.middlewares.set(G+J,[]);U?.forEach((L)=>{if(!this.middlewares.get(G+J)?.includes(L))this.middlewares.get(G+J)?.push(L)})});for(let[U,J]of z){const L=G+J?.path,Y=J.handler[0],$=J.method[0];this.trie.insert(L,{handler:Y,method:$})}F.trie=new V}#z(G,F,z){if(typeof F!=="string")throw new Error("Path must be a string type");if(typeof G!=="string")throw new Error("method must be a string type");const U=z.slice(0,-1),J=z[z.length-1];if(!this.middlewares.has(F))this.middlewares.set(F,[]);U.forEach((L)=>{if(F==="/"){if(!this.globalMiddlewares.includes(L))this.globalMiddlewares.push(L)}else if(!this.middlewares.get(F)?.includes(L))this.middlewares.get(F)?.push(L)}),this.trie.insert(F,{handler:J,method:G})}use(G,F){if(typeof G==="function"){if(!this.globalMiddlewares.includes(G))return this.globalMiddlewares.push(G)}const z=G;if(!this.middlewares.has(z))this.middlewares.set(z,[]);if(!this.middlewares.get(z)?.includes(F))this.middlewares.get(z)?.push(F)}get(G,...F){return this.#z("GET",G,F),this}post(G,...F){return this.#z("POST",G,F),this}put(G,...F){return this.#z("PUT",G,F),this}patch(G,...F){return this.#z("PATCH",G,F),this}delete(G,...F){return this.#z("DELETE",G,F),this}}class v extends M{constructor(){super()}#z(G,F,z){if(!this.trie.root.subMiddlewares.has(F))this.trie.root.subMiddlewares.set(F,[]);const U=z.slice(0,-1),J=this.trie.root.subMiddlewares.get(F);U.forEach((Y)=>{if(!J?.includes(Y))J?.push(Y)});const L=z[z.length-1];this.trie.insert(F,{handler:L,method:G})}get(G,...F){return this.#z("GET",G,F),this}post(G,...F){return this.#z("POST",G,F),this}put(G,...F){return this.#z("PUT",G,F),this}patch(G,...F){return this.#z("PATCH",G,F),this}delete(G,...F){return this.#z("DELETE",G,F),this}}var q=v;export{q as default};
